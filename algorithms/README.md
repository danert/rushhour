# Algoritmes

#### Random Algoritme (oplossing gevonden voor alle borden)
Met het gebruik van het random-algoritme hebben we voor ieder bord een oplossing gevonden. Dit algoritme zoekt een willekeurige auto op het bord en verplaatst hem over een willekeurige afstand. Dit algoritme hoeft niks op te slaan (in tegenstelling tot de andere algoritmes in onze vergelijking) Dit zorgt er dan ook voor dat de random algoritme het snelst een oplossing vindt. Het random algoritme zet willekeurige stappen en hoeft alleen deze stappen (de route) te onthouden terwijl de breadth-first langzaam een tree afgaat die steeds groter wordt. 

#### Random Algoritme (infinite)
Dit algoritme werkt hetzelfde als het random algoritme hierboven, maar stopt niet zodra er een oplossing is gevonden. Het slaat het aantal stappen van deze oplossing op als een zogenaamde 'bound' en gaat opnieuw op zoek naar een oplossing. Zodra bij het zoeken van een oplossing meer stappen zijn gezet dan de bound, begint het algoritme opnieuw naar het zoeken van een nieuwe oplossing. Zodra er een kortere oplossing wordt gevonden, wordt dit de nieuwe bound en herhaalt het proces zich opnieuw. Iedere oplossing wordt geprint in de terminal. Om het algoritme te stoppen maak je gebruik van de command _ctrl + c_.

#### Breadth-First Algoritme (oplossing voor eerste vier borden)
Het breadth-first algoritme vindt gegarandeerd de best mogelijke oplossing. Met de beste oplossing wordt het minst aantal stappen bedoeld. Dit algoritme vormt een tree met alle mogelijke moves, waarbij het elke generatie stap voor stap afgaat. Het nadeel van dit algoritme is dat deze vrij langzaam te werk gaat. Voor de eerste drie borden met een grootte van 6x6 vindt het algoritme nog binnen een paar minuten de beste oplossing, aangezien de statespace relatief klein is (kleiner dan een miljoen). Bij de grotere borden duurt het vinden van een oplossing significant langer. De statespace voor deze borden is dan namelijk een getal met bijna 20 nullen.

#### Depth-First (oplossing gevonden voor eerste vier borden)
Voor de borden groter dan 6x6 komt een depth-first algoritme beter van pas. Dit algoritme gaat net als de breadth-first een tree af, maar de depth-first slaat slechts één pad op in zijn geheugen. Hierdoor is het algoritme veel sneller dan de breadth-first, maar deze garandeert niet dat de beste oplossing gevonden wordt. Aan de depth-first kan een grens (bound) worden meegegeven om het algoritme op die manier sneller en efficiënter te maken: de grens (bound) kan bijvoorbeeld worden gesteld op de kortste oplossing die is gevonden met de andere algoritmes. Bij een bound van bijvoorbeeld 30 zal het algoritme niet verder gaan dan 30 generaties in de tree (en dus ook geen oplossing vinden die langer is dan 30 stappen).
